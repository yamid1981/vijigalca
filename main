/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2024 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "fatfs.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "hd44780.h"
#include "sd.h"
	  FATFS FatFs;
	  FIL Fil;
	  FRESULT FR_Status;
	  FATFS *FS_Ptr;
	  UINT RWC, WWC; // Read/Write Word Counter
	  DWORD FreeClusters;
	  uint32_t TotalSize, FreeSpace;
uint8_t block_data[512];  //Массив для чтения данных
uint32_t root_begin;    //Физический адрес начала корневого каталога
uint32_t cluster_2_add;    //Физический адрес кластера №2
uint16_t fat_start_add;    //номер блока, с которого начинается таблица FAT
uint8_t fat_block[512];    //Массив, в который будем читать блок FAT таблицы
uint32_t root_cluster;    //Первый кластер корневого каталога
uint8_t sector_per_clust;    //количество секторов в кластере
uint16_t root_volume;    //Размер корневого каталога в блоках
uint16_t boot_sector;    //Загрузочный сектор
uint16_t root_count=0; // Счётчик прочитанных блоков корневого католога
uint32_t first_cluster; //Первый кластер файла
uint32_t tim_knipk=0;
uint32_t file_size=0;


char dannie[10240];
char dannie1[10240];

char _String1[16];
char _String2[40];
char _String3[16];
char stroka1[16];
char stroka2[16];
_Bool red_blok_new=0;
_Bool konc_x,konc_y;
_Bool rejim_nuul=0;
_Bool red_xy=0;
_Bool rejim_red=0;
_Bool _kn_vverh,_kn_vniz,_kn_lazer_5,_kn_pusk_cik,_kn_gribok,_kn_vvod;
_Bool privod_on_off=0;
_Bool sost_lazer=0;
_Bool knopka_on=1;
_Bool cikl_otrabotan=0;
_Bool laz_vkl = 0;
_Bool _yd_vverh=0;
_Bool _yd_vniz=0;
uint8_t _cikl=0;
int8_t temp_menu=0;
uint16_t muz[] = {470,450,425,402,379,358,338,319,301,291,268,253,238};
int32_t tek_scet_x=0;
int32_t tek_scet_y=0;
int32_t zadanie_x=0;
int32_t zadanie_y=0;
int32_t tek_kadr=0;
int32_t tek_blok=0;
int32_t vsego_blokov=0;
int32_t tim_yderj_vverh=0;
int32_t tim_yderj_vniz=0;
int viborka=0;
_Bool vip =0;
_Bool upd_zad=0;
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
SPI_HandleTypeDef hspi1;

TIM_HandleTypeDef htim2;
TIM_HandleTypeDef htim3;
TIM_HandleTypeDef htim4;

/* USER CODE BEGIN PV */

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_SPI1_Init(void);
static void MX_TIM2_Init(void);
static void MX_TIM3_Init(void);
static void MX_TIM4_Init(void);
/* USER CODE BEGIN PFP */
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */
void nul(void)
{
	if (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_12) == GPIO_PIN_RESET) konc_x = 1;
	else konc_x = 0;
	if (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_13) == GPIO_PIN_RESET) konc_y = 1;
	else konc_y = 0;
}
__STATIC_INLINE void DelayMicro(__IO uint32_t micros)
{
	micros *=(SystemCoreClock / 1000000) / 5;
	while (micros--);
}
void _diskio_error(uint32_t temp,char qwer[16])
{
	  lcd_clear();
	  lcd_set_xy(0, 0);
	  lcd_out(qwer);
	  lcd_set_xy(0, 1);
	    if (temp==1)   lcd_out("ОшибкаВвод/Вывод");
	    if (temp==2)   lcd_out("ОшибкКонтроляЗап");
	    if (temp==3)   lcd_out("SDнеIнициализиро");
	    if (temp==4)   lcd_out("Нет такого файла");
	    if (temp==5)   lcd_out("Нет такого пути");
	    if (temp==6)   lcd_out("ПутьCинтаксисErr");
	    if (temp==7)   lcd_out("Доступ запрещен");
	    if (temp==8)   lcd_out("Доступ запрещен");
	    if (temp==9)   lcd_out("file/путьНеопред");
	    if (temp==10)  lcd_out("Защита от записи");
	    if (temp==11)  lcd_out("NЛогДискНеДейств");
	    if (temp==12)  lcd_out("НетРабОблостТома");
	    if (temp==13)  lcd_out("Нет FAT облости");
	    if (temp==14)  lcd_out("Выпf_mkfs()ошибк");
	    if (temp==15)  lcd_out("НетДоступЗаВремя");
	    if (temp==16)  lcd_out("Доступ Запрещен");
	    if (temp==17)  lcd_out("LFNБуфрНеВыделен");
	    if (temp==18)  lcd_out("file > _FS_LOCK");
	    if (temp==19)  lcd_out("Ошибка параметра");
}
void spik (uint16_t nota,uint16_t dlit)
{
for (uint32_t temp=0; temp<dlit; temp++)
		{
    	HAL_GPIO_TogglePin(Speaker_GPIO_Port, Speaker_Pin);
		DelayMicro(nota);
		}
HAL_Delay(dlit);
}
void pic_error()
{
	 for (int q=0;q<1000;q++)
	    {
	    HAL_GPIO_TogglePin(Speaker_GPIO_Port, Speaker_Pin);
	    DelayMicro(q);
	    }
	 for (int q=0;q<1000;q++)
	    {
	    HAL_GPIO_TogglePin(Speaker_GPIO_Port, Speaker_Pin);
	    DelayMicro(1000-q);
	    }
}
void red_blok_1()
{
	HAL_GPIO_WritePin(led_GPIO_Port, led_Pin, GPIO_PIN_RESET);
	  char RW_Buffer[10240];
	  FR_Status =f_lseek(&Fil,(tek_blok+1)*10240);//сдвиг при чтении на
			  if(FR_Status != FR_OK)
			  {
				   _diskio_error(FR_Status,"command f_lseek");
				   HAL_GPIO_WritePin(led_GPIO_Port, led_Pin, GPIO_PIN_SET);
				   while(1){pic_error();spik(muz[5],100);spik(muz[5],100);spik(muz[5],100);spik(muz[0],200);};
			  }

	  //for(int i=0;i<1024;i++) {RW_Buffer[i]=0;};
	  FR_Status =f_read(&Fil, RW_Buffer, 10240, &RWC);
	  if(FR_Status != FR_OK)
	  {
		   _diskio_error(FR_Status,"command f_read");
		   HAL_GPIO_WritePin(led_GPIO_Port, led_Pin, GPIO_PIN_SET);
		   while(1){pic_error();spik(muz[5],100);spik(muz[5],100);spik(muz[5],100);spik(muz[0],200);};
	  }
	  for	(int a=0;a<10240;a++)
	  {
		  dannie1[a]=  0; dannie1[a]=  RW_Buffer[a];
	  }
	  HAL_GPIO_WritePin(led_GPIO_Port, led_Pin, GPIO_PIN_SET);
}
void red_blok_1_2()
{
	  char RW_Buffer[10240];
	  viborka=0;
	  FR_Status =f_lseek(&Fil,tek_blok*10240);//сдвиг при чтении на
			  if(FR_Status != FR_OK)
			  {
				   _diskio_error(FR_Status,"command f_lseek");
				   HAL_GPIO_WritePin(led_GPIO_Port, led_Pin, GPIO_PIN_SET);
				   while(1){pic_error();spik(muz[5],100);spik(muz[5],100);spik(muz[5],100);spik(muz[0],200);};
			  }

	  //for(int i=0;i<1024;i++) {RW_Buffer[i]=0;};
	  FR_Status =f_read(&Fil, RW_Buffer, 10240, &RWC);
	  if(FR_Status != FR_OK)
	  {
		   _diskio_error(FR_Status,"command f_read");
		   HAL_GPIO_WritePin(led_GPIO_Port, led_Pin, GPIO_PIN_SET);
		   while(1){pic_error();spik(muz[5],100);spik(muz[5],100);spik(muz[5],100);spik(muz[0],200);};
	  }
	  for	(int a=0;a<10240;a++)
	  {
		  dannie[a]=  0; dannie[a]=  RW_Buffer[a];
	  }
	  for	(int a=0;a<10240;a++) RW_Buffer[a]=0;

	  FR_Status =f_lseek(&Fil,(tek_blok+1)*10240);//сдвиг при чтении на
			  if(FR_Status != FR_OK)
			  {
				   _diskio_error(FR_Status,"command f_lseek");
				   HAL_GPIO_WritePin(led_GPIO_Port, led_Pin, GPIO_PIN_SET);
				   while(1){pic_error();spik(muz[5],100);spik(muz[5],100);spik(muz[5],100);spik(muz[0],200);};
			  }

	  //for(int i=0;i<1024;i++) {RW_Buffer[i]=0;};
	  FR_Status =f_read(&Fil, RW_Buffer, 10240, &RWC);
	  if(FR_Status != FR_OK)
	  {
		   _diskio_error(FR_Status,"command f_read");
		   HAL_GPIO_WritePin(led_GPIO_Port, led_Pin, GPIO_PIN_SET);
		   while(1){pic_error();spik(muz[5],100);spik(muz[5],100);spik(muz[5],100);spik(muz[0],200);};
	  }
	  for	(int a=0;a<10240;a++)
	  {
		  dannie1[a]=  0; dannie1[a]=  RW_Buffer[a];
	  }
}

void privoda_ON()
{
	HAL_GPIO_WritePin(XY_ENABLE_GPIO_Port, XY_ENABLE_Pin, GPIO_PIN_RESET);
	privod_on_off=1;
}
void lazer_ON()
{
	HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_1);
	sost_lazer=1;
}
void lazer_OFF()
{
	HAL_TIM_PWM_Stop(&htim2, TIM_CHANNEL_1);
	sost_lazer=0;
}
void privoda_OFF()
{
	HAL_GPIO_WritePin(XY_ENABLE_GPIO_Port, XY_ENABLE_Pin, GPIO_PIN_SET);
	privod_on_off=0;
//	_cikl=0;
}
void OFF()
{
		privoda_OFF();
		lazer_OFF();
}
void obnulenie()
{
	tek_scet_x=0;
	tek_scet_y=0;
	zadanie_x=0;
	zadanie_y=0;
}

void shag_x_plus ()
{
	HAL_GPIO_WritePin(X_Dir_GPIO_Port, X_Dir_Pin, GPIO_PIN_SET);
	DelayMicro(1);
	HAL_GPIO_WritePin(X_STEP_GPIO_Port, X_STEP_Pin, GPIO_PIN_SET);
	DelayMicro(1);
	HAL_GPIO_WritePin(X_STEP_GPIO_Port, X_STEP_Pin, GPIO_PIN_RESET);
	vip=0;
}
void shag_x_minus ()
{
	HAL_GPIO_WritePin(X_Dir_GPIO_Port, X_Dir_Pin, GPIO_PIN_RESET);
	DelayMicro(1);
	HAL_GPIO_WritePin(X_STEP_GPIO_Port, X_STEP_Pin, GPIO_PIN_SET);
	DelayMicro(1);
	HAL_GPIO_WritePin(X_STEP_GPIO_Port, X_STEP_Pin, GPIO_PIN_RESET);
	vip=0;
}
void shag_y_plus ()
{
	HAL_GPIO_WritePin(Y_Dir_GPIO_Port, Y_Dir_Pin, GPIO_PIN_SET);
	DelayMicro(1);
	HAL_GPIO_WritePin(Y_STEP_GPIO_Port, Y_STEP_Pin, GPIO_PIN_SET);
	DelayMicro(0);
	HAL_GPIO_WritePin(Y_STEP_GPIO_Port, Y_STEP_Pin, GPIO_PIN_RESET);
	vip=0;
}
void shag_y_minus ()
{
	HAL_GPIO_WritePin(Y_Dir_GPIO_Port, Y_Dir_Pin, GPIO_PIN_RESET);
	DelayMicro(1);
	HAL_GPIO_WritePin(Y_STEP_GPIO_Port, Y_STEP_Pin, GPIO_PIN_SET);
	DelayMicro(1);
	HAL_GPIO_WritePin(Y_STEP_GPIO_Port, Y_STEP_Pin, GPIO_PIN_RESET);
	vip=0;
}
void strelki()
{
	lcd_set_xy(15, 0);lcd_send(217,DATA);
	lcd_set_xy(15, 1);lcd_send(218,DATA);
}
_Bool kadr_detekt(int kadr)
{
	for (int i=0;i<16;i++) _String1[i]=0;
	for (int i=0;i<40;i++) _String2[i]=0;
	for (int i=0;i<16;i++) _String3[i]=0;
	itoa(kadr, _String3, 10);
	for (;viborka<10240;viborka++)
	{
		if (dannie[viborka]=='N')
		{
			for (int k=0;k<40;k++) _String2[k]=32;
			int j=0;
			while (dannie[viborka]!=';' && viborka<10240)
			{
				_String2[j]=dannie[viborka];viborka++;j++;
			}
			int q=1;
			while (_String2[q] != '=' && q<40)
			{
				_String1[q-1]=_String2[q];q++;
			}
			if (_String1[0]==_String3[0] && _String1[1]==_String3[1] && _String1[2]==_String3[2] && _String1[3]==_String3[3] && _String1[4]==_String3[4]
				&& _String1[5]==_String3[5]&& _String1[6]==_String3[6]&& _String1[7]==_String3[7]&& _String1[8]==_String3[8]&& _String1[9]==_String3[9]) return 1;
		}
	}
for (int i=0; i<10240; i++)dannie[i]=dannie1[i];
upd_zad=1;
viborka=0;
return 0;
}
void vse()
{
	  lcd_clear();
	  lcd_set_xy(0, 0);
	  lcd_out(" КОНЕЦ ЦIКЛА!!! ");
	  lcd_set_xy(0, 1);
	  lcd_out(" КОНЕЦ ЦIКЛА!!! ");
	while(1)
	{
	lazer_OFF();
	spik(muz[0],80);  spik(muz[1],80);  spik(muz[2],80);  spik(muz[3],80);  spik(muz[4],80);  spik(muz[3],80);  spik(muz[2],80);  spik(muz[1],80);  spik(muz[0],80);
	HAL_Delay(200);
	}
}
void cikl_off()
{
		_cikl=0;
		OFF();
		tek_kadr=0;
		tek_blok=0;
		cikl_otrabotan=1;
}
void init_zadanie()
{
	char _x[15] = {32,};
	char _y[15] = {32,};
	while (kadr_detekt(tek_kadr)==0);
	int j=0,k=0;
	for	(int i=0;i<40;i++)
	{
			while(_String2[i] != '=' ) i++;
			i++;
			while(_String2[i] != ',') {_x[j]=_String2[i];j++;i++;};
			i++;
			while(_String2[i] != 32 )  {_y[k]=_String2[i];k++;i++;};
			break;
	}
	zadanie_x = atoi(_x);
	zadanie_y = atoi(_y);
	if (zadanie_x==0 && zadanie_y==0)cikl_off();
}
void cikl(void)
{
if (_cikl != 1) return;
if (_cikl == 1  && tek_scet_x == zadanie_x && tek_scet_y == zadanie_y && sost_lazer==0 && vip==0)
	{
	lazer_ON();
	return;
	}
if (_cikl == 1  && tek_scet_x == zadanie_x && tek_scet_y == zadanie_y && sost_lazer==1 && vip==0)
	{
	lazer_OFF();
	vip=1;
	}
if (vip == 1)
	{
	tek_kadr++;
	init_zadanie();
	}
}
void  X_step(void)
{
if (privod_on_off==0)return;//0-vikkl 1-vkl
if (tek_scet_x<zadanie_x)
		{
		shag_x_plus();
		tek_scet_x++;
		}
if (tek_scet_x>zadanie_x)
		{
		shag_x_minus();
		tek_scet_x--;
		}

}
void  Y_step(void)
{
if (privod_on_off==0)return;
if (tek_scet_y<zadanie_y)
		{
		shag_y_plus();
		tek_scet_y++;
		}
if (tek_scet_y>zadanie_y)
		{
		shag_y_minus();
		tek_scet_y--;
		}
}

static void SD_Card_maumt_red_vijigalka(void)
{
//	  char _stroka1[16]={0,};
//	  char _stroka2[16]={0,};
  FR_Status = f_mount(&FatFs, "", 1);//инициализация и монтаж
  if (FR_Status != FR_OK)
  {
   _diskio_error(FR_Status,"Команда f_mount");
   HAL_GPIO_WritePin(led_GPIO_Port, led_Pin, GPIO_PIN_SET);
   while(1){pic_error();spik(muz[5],100);spik(muz[5],100);spik(muz[5],100);spik(muz[0],200);};
  }
  else {lcd_set_xy(0, 0);lcd_out("Командf_mount OK");}
  HAL_Delay(1000);
  //------------------[ Get & Print The SD Card Size & Free Space ]--------------------
  f_getfree("", &FreeClusters, &FS_Ptr);//объем и оставшиеся место
  TotalSize = (uint32_t)((FS_Ptr->n_fatent - 2) * FS_Ptr->csize * 0.5)/1000;
  FreeSpace = (uint32_t)(FreeClusters * FS_Ptr->csize * 0.5)/1000;
  itoa(TotalSize, stroka1, 10);
  itoa(FreeSpace, stroka2, 10);
  lcd_clear();
  lcd_set_xy(0, 0);
  lcd_out("Всего"); lcd_set_xy(6, 0);  lcd_out(stroka1);
  lcd_set_xy(12, 0);  lcd_out("(мб)");
  lcd_set_xy(0, 1);
  lcd_out("Остал"); lcd_set_xy(6, 1);  lcd_out(stroka2);
  lcd_set_xy(12, 1);lcd_out("(мб)");
  HAL_Delay(1000);
  // Open The File
  FR_Status = f_open(&Fil, "vijigalka.txt", FA_READ);
  if(FR_Status != FR_OK)
  {
	   _diskio_error(FR_Status,"on vijigalka.txt");
	   HAL_GPIO_WritePin(led_GPIO_Port, led_Pin, GPIO_PIN_SET);
	   while(1){pic_error();spik(muz[5],100);spik(muz[5],100);spik(muz[5],100);spik(muz[0],200);};
  }
  lcd_clear();
  lcd_set_xy(0, 0);
  lcd_out("on vijigalka.txt");
  lcd_set_xy(0, 1);
  lcd_out("ВЫПОЛНЕНО!!!");
  HAL_Delay(1000);
  file_size=f_size(&Fil);
  for (int i=0;i<16;i++) {stroka1[i]=0;};
  itoa(f_size(&Fil), stroka1, 10);
  lcd_clear();
  lcd_set_xy(0, 0);
  lcd_out("Файл на (байт)");
  lcd_set_xy(0, 1);
  lcd_out(stroka1);
  HAL_Delay(1000);
  lcd_clear();
  char RW_Buffer[10240];
  char tem[10] = {32,};
  FR_Status =f_lseek(&Fil,tek_blok*10240);//сдвиг при чтении на
		  if(FR_Status != FR_OK)
		  {
			   _diskio_error(FR_Status,"command f_lseek");
			   HAL_GPIO_WritePin(led_GPIO_Port, led_Pin, GPIO_PIN_SET);
			   while(1){pic_error();spik(muz[5],100);spik(muz[5],100);spik(muz[5],100);spik(muz[0],200);};
		  }

  //for(int i=0;i<1024;i++) {RW_Buffer[i]=0;};
  FR_Status =f_read(&Fil, RW_Buffer, 10240, &RWC);
  if(FR_Status != FR_OK)
  {
	   _diskio_error(FR_Status,"command f_read");
	   HAL_GPIO_WritePin(led_GPIO_Port, led_Pin, GPIO_PIN_SET);
	   while(1){pic_error();spik(muz[5],100);spik(muz[5],100);spik(muz[5],100);spik(muz[0],200);};
  }
  for	(int a=0;a<10240;a++)
  {
	  dannie[a]=  RW_Buffer[a];
  }
  for	(int a=0;a<1000;a++)
  {
	  if (dannie[a]==42)
		  {
		  if (dannie[a+1]!=10) tem[0]=dannie[a+1];
		  else break;
		  if (dannie[a+2]!=10) tem[1]=dannie[a+2];
		  else break;
		  if (dannie[a+3]!=10) tem[2]=dannie[a+3];
		  else break;
		  if (dannie[a+4]!=10) tem[3]=dannie[a+4];
		  else break;
		  if (dannie[a+5]!=10) tem[4]=dannie[a+5];
		  else break;
		  if (dannie[a+6]!=10) tem[5]=dannie[a+6];
		  else break;
		  if (dannie[a+7]!=10) tem[6]=dannie[a+7];
		  else break;
		  if (dannie[a+8]!=10) tem[7]=dannie[a+8];
		  else break;
		  if (dannie[a+9]!=10) tem[8]=dannie[a+9];
		  else break;
		  if (dannie[a+10]!=10)tem[9]=dannie[a+10];
		  else break;
		  }
  }
  vsego_blokov= atoi(tem);
//  int i=0;
//	for (;i<10240;i++)
//	{
//		if (dannie[i]=='N')
//		{
//			for (int k=0;k<16;k++) _stroka1[k]=0;
//			for (int k=0;k<16;k++) _stroka2[k]=0;
//			int j=0;
//			while (dannie[i]!=';' && i<10240)
//			{
//				_stroka2[j]=dannie[i];i++;j++;
//			}
//			int q=1;
//			while (_stroka2[q] != '=' && q<16)
//			{
//				_stroka1[q-1]=_stroka2[q];q++;
//			}
//			kadr_blok_min = atoi (_stroka1);
//			i=10239;
//		}
//	}
//	i=10239;
//	for (;i!=0;i--)
//	{
//		if (dannie[i]=='N')
//		{
//			for (int k=0;k<16;k++) _stroka1[k]=0;
//			for (int k=0;k<16;k++) _stroka2[k]=0;
//			int j=0;
//			while (dannie[i]!=';' && i<10240)
//			{
//				_stroka2[j]=dannie[i];i++;j++;
//			}
//			int q=1;
//			while (_stroka2[q] != '=' && q<16)
//			{
//				_stroka1[q-1]=_stroka2[q];q++;
//			}
//			kadr_blok_max = atoi (_stroka1);
//			break;
//		}
//	}
//  f_close(&Fil);
//  lcd_clear();
//  lcd_set_xy(0, 0);
//  char temp[16];
//  for (int i=0;i<16;i++) {temp[i]=RW_Buffer[i];};
//  lcd_out(temp);
//  lcd_set_xy(0, 1);
//  for (int i=15;i<32;i++) {temp[i-15]=RW_Buffer[i];};
//  lcd_out(temp);
//  *(uint32_t *) 0x40012c2cU=(uint16_t)20000;
//  sprintf(TxBuffer, "Free SD Card Space: %lu Bytes\r\n\n", FreeSpace);
//  UART_Print(TxBuffer);
}
void NUL_CIKL()
{
privoda_ON();
//по Х
zadanie_x=-1000000;
TIM3->ARR=10000;
while (1) 	if (konc_x==1) break;
tek_scet_x=0;
zadanie_x=0;
zadanie_x=125;
while (1) if (tek_scet_x==125) break;
TIM3->ARR=20000;
zadanie_x=-1000000;
while (1)if (konc_x==1) break;
tek_scet_x=0;
zadanie_x=0;
TIM3->ARR=2000;
//по y
zadanie_y=-1000000;
TIM3->ARR=10000;
while (1) 	if (konc_y==1) break;
tek_scet_y=0;
zadanie_y=0;
zadanie_y=125;
while (1) if (tek_scet_y==125) break;
TIM3->ARR=20000;
zadanie_y=-1000000;
while (1)if (konc_y==1) break;
tek_scet_y=0;
zadanie_y=0;
TIM3->ARR=2000;
zadanie_x=30;
zadanie_y=30;
while (1) if (tek_scet_x==30 && tek_scet_y==30 ) break;
tek_scet_x=0;
tek_scet_y=0;
zadanie_x=0;
zadanie_y=0;
rejim_nuul=0;
rejim_red=0;
}
void KNOPKI()//hal delay нельзя, b9 лазер , b8 пуск , b7 стоп грибок, b6 интер
{
	if (HAL_GPIO_ReadPin(vverh_GPIO_Port, vverh_Pin) == GPIO_PIN_RESET) {_kn_vverh = 1;}//вверх
	else _kn_vverh = 0;
	if (HAL_GPIO_ReadPin(vniz_GPIO_Port, vniz_Pin) == GPIO_PIN_RESET)  {_kn_vniz = 1;}//вниз
	else _kn_vniz = 0;
	if (HAL_GPIO_ReadPin(lazer_5_GPIO_Port, lazer_5_Pin) == GPIO_PIN_RESET)	{
		_kn_lazer_5 = 1;
		laz_vkl=!laz_vkl;
    	if (laz_vkl==1) lazer_ON();
    	else lazer_OFF();
	}//лазер 5%
	else _kn_lazer_5 = 0;
	if (HAL_GPIO_ReadPin(pusk_cikl_GPIO_Port, pusk_cikl_Pin) == GPIO_PIN_RESET)	//пуск
	{
		if (_kn_vvod != 1)
			{
			privoda_ON();
			_kn_pusk_cik = 1;
	        TIM2->CCR1=60;
			}
	}
	else _kn_pusk_cik = 0;
	if (HAL_GPIO_ReadPin(gribok_GPIO_Port, gribok_Pin) == GPIO_PIN_RESET){_kn_gribok = 1;_cikl = 0;OFF();}//грибок
	else _kn_gribok = 0;
	if (HAL_GPIO_ReadPin(vvod_GPIO_Port, vvod_Pin) == GPIO_PIN_RESET){_kn_vvod = 1;}//ввод
	else _kn_vvod  = 0;
	if (_kn_vverh==0 && _kn_vniz==0 && _kn_lazer_5==0 && _kn_pusk_cik==0 && _kn_gribok==0 && _kn_vvod==0)knopka_on=0;
	if (_kn_vverh==1 || _kn_vniz==1 || _kn_lazer_5==1 || _kn_pusk_cik==1 || _kn_gribok==1 || _kn_vvod==1)knopka_on=1;
	if (_kn_vverh==1)	tim_yderj_vverh++;
	if (_kn_vniz==1 )	tim_yderj_vniz++;
	if (_kn_vverh==0) 	tim_yderj_vverh=0;
	if (_kn_vniz==0) 	tim_yderj_vniz=0;
	if (_kn_vvod==1)	tim_knipk++;
	if (_kn_vvod==0)    tim_knipk=0;
	if (tim_knipk>=200) {rejim_red=!rejim_red;tim_knipk=0;};
	if (tim_knipk==100) {red_xy=!red_xy;};
	if (tim_yderj_vverh>=200) _yd_vverh=1;
	else _yd_vverh=0;
	if (tim_yderj_vniz>=200) _yd_vniz=1;
	else _yd_vniz=0;
}
void clr()
{
	for (int i=0;i<16;i++) {stroka1[i]=32;stroka2[i]=32;}
}
void clr_0()
{
	for (int i=0;i<16;i++) if (stroka2[i]==0) stroka2[i]=32;
}

void _init_menu()
{
	if (temp_menu==0)//мощность лазера
	{
		clr();
		stroka1[0]=0x4d;stroka1[1]=0x4f;stroka1[2]=0xE6;stroka1[3]=0x48;stroka1[4]=0x4f;stroka1[5]=0x43;stroka1[6]=0x54;stroka1[7]=0x62;
		stroka1[8]=0x20;stroka1[9]=0xA7;stroka1[10]=0x41;stroka1[11]=0x33;stroka1[12]=0x45;stroka1[13]=0x50;stroka1[14]=0x41;stroka1[15]=0x20;
		itoa((TIM2->CCR1)*100/60, stroka2, 10);
		stroka2[15]=0x25;
		clr_0();
	}
	  if (temp_menu==0 && _kn_vverh==1 && rejim_red==1)
	  {
			if (TIM2->CCR1<60) TIM2->CCR1=(TIM2->CCR1)+1;
	  }
	  if (temp_menu==0 && _kn_vniz==1 && rejim_red==1)
	  {
			TIM2->CCR1=(TIM2->CCR1)-1;
			if (TIM2->CCR1==0) TIM2->CCR1=60;
	  }
		if (temp_menu==1)//скорость осей
		{
			clr();
			stroka1[0]=0x43;stroka1[1]=0x4B;stroka1[2]=0x4f;stroka1[3]=0x50;stroka1[4]=0x4f;stroka1[5]=0x43;stroka1[6]=0x54;stroka1[7]=0x62;
			stroka1[8]=0xA8;stroka1[9]=0x50;stroka1[10]=0xA5;stroka1[11]=0x42;stroka1[12]=0x4F;stroka1[13]=0xE0;stroka1[14]=0x2E;stroka1[15]=0x20;
			char _stroka1[16]={0,};
			int speed_x=TIM3->ARR;
			itoa(speed_x, _stroka1, 10);
			stroka2[0]='S';stroka2[1]='=';stroka2[2]=_stroka1[0];stroka2[3]=_stroka1[1];stroka2[4]=_stroka1[2];stroka2[5]=_stroka1[3];stroka2[6]=_stroka1[4];stroka2[7]=' ';
			stroka2[8]=' ';stroka2[9]=' ';stroka2[10]=' ';
			clr_0();
		}
	  if (temp_menu==1 && rejim_red==1)
	  {
			  if (red_xy==0)
			  	  {
					lcd_set_xy(5, 1);  lcd_send(0x3c,DATA);
					lcd_set_xy(13, 1);  lcd_send(0x20,DATA);
					if (_kn_vverh==1)if (TIM3->ARR<999) TIM3->ARR = (TIM3->ARR) + 10;
					if (_kn_vniz==1)if (TIM3->ARR>49) TIM3->ARR = (TIM3->ARR) - 10;
			  	  }
			  if (red_xy==1)
			  	  {
					lcd_set_xy(5, 1);  lcd_send(0x20,DATA);
					lcd_set_xy(13, 1);  lcd_send(0x3c,DATA);
					if (_kn_vverh==1)if (TIM3->ARR<999) TIM3->ARR = (TIM3->ARR) + 100;
					if (_kn_vniz==1)if (TIM3->ARR>49) TIM3->ARR = (TIM3->ARR) - 100;
			  	  }

	  }
	  if (temp_menu==2)//время прожига
	  {
			clr();
			stroka1[0]=Rus('В');stroka1[1]=Rus('Р');stroka1[2]=Rus('Е');stroka1[3]=Rus('М');stroka1[4]=Rus('Я');stroka1[5]=Rus(' ');stroka1[6]=Rus('П');stroka1[7]=Rus('Р');
			stroka1[8]=Rus('О');stroka1[9]=Rus('Ж');stroka1[10]=Rus('I');stroka1[11]=Rus('Г');stroka1[12]=Rus('А');stroka1[13]=Rus(' ');stroka1[14]=Rus(' ');stroka1[15]=0x20;
			itoa(TIM4->ARR, stroka2, 10);
			clr_0();
	  }
	  if (temp_menu==2 && _kn_vverh==1 && rejim_red==1)if (TIM4->ARR<60001) TIM4->ARR = (TIM4->ARR) + 100;
	  if (temp_menu==2 && _kn_vniz==1 && rejim_red==1)if (TIM4->ARR>999) TIM4->ARR = (TIM4->ARR) - 100;

	  if (temp_menu==3)//текущия координаты
	  {
			clr();
			stroka1[0]=Rus('Т');stroka1[1]=Rus('Е');stroka1[2]=Rus('К');stroka1[3]=Rus('.');stroka1[4]=Rus('К');stroka1[5]=Rus('О');stroka1[6]=Rus('О');stroka1[7]=Rus('Р');
			stroka1[8]=Rus('Д');stroka1[9]=Rus('I');stroka1[10]=Rus('Н');stroka1[11]=Rus('А');stroka1[12]=Rus('Т');stroka1[13]=Rus('Ы');stroka1[14]=Rus(' ');stroka1[15]=0x20;
			char _stroka1[16]={0,};
			char _stroka2[16]={0,};
			itoa(tek_scet_x, _stroka1, 10);
			itoa(tek_scet_y, _stroka2, 10);
			stroka2[0]='X';stroka2[1]='=';stroka2[2]=_stroka1[0];stroka2[3]=_stroka1[1];stroka2[4]=_stroka1[2];stroka2[5]=_stroka1[3];stroka2[6]=_stroka1[4];stroka2[7]=_stroka1[5];
			stroka2[8]='Y';stroka2[9]='=';stroka2[10]=_stroka2[0];stroka2[11]=_stroka2[1];stroka2[12]=_stroka2[2];stroka2[13]=_stroka2[3];stroka2[14]=_stroka2[4];stroka2[15]=_stroka2[5];
		  clr_0();
	  }
	  if (temp_menu==3 && _kn_vverh==1 && rejim_red==1)
	  {
          privoda_ON();
		  while (_kn_vverh==1 && red_xy==0)	{zadanie_x++;DelayMicro(500);}
		  while (_kn_vverh==1 && red_xy==1)	{zadanie_y++;DelayMicro(500);}
	  }
	  if (temp_menu==3 && _kn_vniz==1 && rejim_red==1)
	  {
		 privoda_ON();
	     while (_kn_vniz==1 && red_xy==0)	{zadanie_x--;DelayMicro(500);}
		 while (_kn_vniz==1 && red_xy==1)	{zadanie_y--;DelayMicro(500);}
	  }
	  if (temp_menu==4)//обнуление
	  {
			clr();
			stroka1[0]=Rus('О');stroka1[1]=Rus('Б');stroka1[2]=Rus('Н');stroka1[3]=Rus('У');stroka1[4]=Rus('Л');stroka1[5]=Rus('Е');stroka1[6]=Rus('Н');stroka1[7]=Rus('I');
			stroka1[8]=Rus('Е');stroka1[9]=Rus(' ');stroka1[10]=Rus('К');stroka1[11]=Rus('О');stroka1[12]=Rus('О');stroka1[13]=Rus('Р');stroka1[14]=Rus('Д');stroka1[15]=0x20;
			char _stroka1[16]={0,};
			char _stroka2[16]={0,};
			itoa(tek_scet_x, _stroka1, 10);
			itoa(tek_scet_y, _stroka2, 10);
			stroka2[0]='X';stroka2[1]='=';stroka2[2]=_stroka1[0];stroka2[3]=_stroka1[1];stroka2[4]=_stroka1[2];stroka2[5]=_stroka1[3];stroka2[6]=_stroka1[4];stroka2[7]=_stroka1[5];
			stroka2[8]='Y';stroka2[9]='=';stroka2[10]=_stroka2[0];stroka2[11]=_stroka2[1];stroka2[12]=_stroka2[2];stroka2[13]=_stroka2[3];stroka2[14]=_stroka2[4];stroka2[15]=_stroka2[5];
		  clr_0();
	  }
	  if (temp_menu==4  && rejim_red==1)
	  {
		  tek_scet_x=0;
		  tek_scet_y=0;
		  zadanie_x=0;
		  zadanie_y=0;
	  }
	  if (temp_menu==5)//Текущий кадр
	  {
			clr();
			stroka1[0]=Rus('Т');stroka1[1]=Rus('Е');stroka1[2]=Rus('К');stroka1[3]=Rus('У');stroka1[4]=Rus('щ');stroka1[5]=Rus('I');stroka1[6]=Rus('Й');stroka1[7]=Rus(' ');
			stroka1[8]=Rus('К');stroka1[9]=Rus('А');stroka1[10]=Rus('Д');stroka1[11]=Rus('Р');stroka1[12]=Rus(' ');stroka1[13]=Rus(' ');stroka1[14]=Rus(' ');stroka1[15]=0x20;
			char _stroka2[16]={0,};
			itoa(tek_kadr, _stroka2, 10);
			  lcd_set_xy(0, 1);
			  lcd_out(_stroka2);
		  clr_0();
	  }
	  if (temp_menu==5 && _kn_vverh==1 && rejim_red==1 && _yd_vverh==0 )if (_kn_vverh==1)tek_kadr++;
	  if (temp_menu==5 && _kn_vniz==1 && rejim_red==1 && _yd_vniz==0)tek_kadr--;
	  if (temp_menu==5 && rejim_red==1 && _yd_vverh==1 )tek_kadr=tek_kadr+100;
	  if (temp_menu==5 && rejim_red==1 && _yd_vniz==1 )tek_kadr=tek_kadr-100;
//	  if (tek_kadr>=kadr_blok_max) tek_kadr=kadr_blok_max;
//	  if (tek_kadr<=kadr_blok_min) tek_kadr=kadr_blok_min;

	  if (temp_menu==6)//Текущий блок
	  {
			clr();
			char _stroka1[16]={0,};//tek_blok
			char _stroka11[10]={0,};//vsego_blok vsego_blokov
            itoa(tek_blok, _stroka1, 10);
            itoa(vsego_blokov, _stroka11, 10);
            stroka1[0]=Rus('Т');stroka1[1]=Rus('Е');stroka1[2]=Rus('К');stroka1[3]=Rus('.');stroka1[4]=Rus('Б');stroka1[5]=Rus('Л');stroka1[6]=Rus('О');stroka1[7]=Rus('К');
            stroka1[8]=Rus('/');stroka1[9]=Rus('В');stroka1[10]=Rus('С');stroka1[11]=Rus('Е');stroka1[12]=Rus('Г');stroka1[13]=Rus('О');stroka1[14]=Rus(' ');stroka1[15]=0x20;
            stroka2[0]=_stroka1[0];
            stroka2[1]=_stroka1[1];
            stroka2[2]=_stroka1[2];
            stroka2[3]=_stroka1[3];
            stroka2[4]=_stroka1[4];
            stroka2[5]=_stroka1[5];
            stroka2[6]=_stroka1[6];
            stroka2[7]=0x20;
            stroka2[8]=_stroka11[0];
            stroka2[9]=_stroka11[1];
           stroka2[10]=_stroka11[2];
           stroka2[11]=_stroka11[3];
           stroka2[12]=_stroka11[4];
           stroka2[13]=_stroka11[5];
           stroka2[14]=_stroka11[6];
           stroka2[15]=_stroka11[7];
		   clr_0();
	  }
	  if (temp_menu==6 && _kn_vverh==1 && rejim_red==1 )
	  {
			char _stroka1[16]={0,};
			char _stroka2[16]={0,};
			if (_kn_vverh==1 && _yd_vverh==0 )
			{
				tek_blok++;
				if (tek_blok>vsego_blokov)tek_blok=vsego_blokov;
				  red_blok_1_2();
				for (int i=0;i<10240;i++)
				{
					if (dannie[i]=='N')
					{
						for (int k=0;k<16;k++) _stroka1[k]=0;
						for (int k=0;k<16;k++) _stroka2[k]=0;
						int j=0;
						while (dannie[i]!=';' && i<10240)
						{
							_stroka2[j]=dannie[i];i++;j++;
						}
						int q=1;
						while (_stroka2[q] != '=' && q<16)
						{
							_stroka1[q-1]=_stroka2[q];q++;
						}
						tek_kadr = atoi (_stroka1);
						return;
					}

				}
			}
			if (_kn_vverh==1 && _yd_vverh==1 )
			{
				tek_blok=tek_blok+100;
				if (tek_blok>vsego_blokov)tek_blok=vsego_blokov;
				  red_blok_1_2();
				for (int i=0;i<10240;i++)
				{
					if (dannie[i]=='N')
					{
						for (int k=0;k<16;k++) _stroka1[k]=0;
						for (int k=0;k<16;k++) _stroka2[k]=0;
						int j=0;
						while (dannie[i]!=';' && i<10240)
						{
							_stroka2[j]=dannie[i];i++;j++;
						}
						int q=1;
						while (_stroka2[q] != '=' && q<16)
						{
							_stroka1[q-1]=_stroka2[q];q++;
						}
						tek_kadr = atoi (_stroka1);
					}

				}
			}

	  }
	  if (temp_menu==6 && _kn_vniz==1 && rejim_red==1)
	  {
			char _stroka1[16]={0,};
			char _stroka2[16]={0,};
			if (_kn_vniz==1 && _yd_vniz==0)
			{
				tek_blok--;
				if (tek_blok<0)tek_blok=0;
				  red_blok_1_2();
				for (int i=0;i<10240;i++)
				{
					if (dannie[i]=='N')
					{
						for (int k=0;k<16;k++) _stroka2[k]=0;
						int j=0;
						while (dannie[i]!=';' && i<10240)
						{
							_stroka2[j]=dannie[i];i++;j++;
						}
						int q=1;
						while (_stroka2[q] != '=' && q<16)
						{
							_stroka1[q-1]=_stroka2[q];q++;
						}
						tek_kadr = atoi (_stroka1);
							break;
					}

				}
			}
			if (_kn_vniz==1 && _yd_vniz==1)
			{
				tek_blok=tek_blok-100;
				if (tek_blok<0)tek_blok=0;
				  red_blok_1_2();
				for (int i=0;i<10240;i++)
				{
					if (dannie[i]=='N')
					{
						for (int k=0;k<16;k++) _stroka2[k]=0;
						int j=0;
						while (dannie[i]!=';' && i<10240)
						{
							_stroka2[j]=dannie[i];i++;j++;
						}
						int q=1;
						while (_stroka2[q] != '=' && q<16)
						{
							_stroka1[q-1]=_stroka2[q];q++;
						}
						tek_kadr = atoi (_stroka1);
							break;
					}

				}
			}
	  }
	  if (temp_menu==7)//привода ON OFF
	  {
			clr();
            stroka1[0]=Rus('П');stroka1[1]=Rus('Р');stroka1[2]=Rus('и');stroka1[3]=Rus('В');stroka1[4]=Rus('О');stroka1[5]=Rus('Д');stroka1[6]=Rus('А');stroka1[7]=Rus(' ');
            stroka1[8]=Rus('В');stroka1[9]=Rus('К');stroka1[10]=Rus('Л');stroka1[11]=Rus('/');stroka1[12]=Rus('О');stroka1[13]=Rus('Т');stroka1[14]=Rus('К');stroka1[15]=Rus('Л');
		   clr_0();
	  }
	  if (temp_menu==7 && rejim_red==1)
	  {
			  if (red_xy==0)
				  {
				  	  privoda_ON();
			          stroka2[0]=Rus('в');stroka2[1]=Rus('к');stroka2[2]=Rus('л');stroka2[3]=Rus('ю');stroka2[4]=Rus('ч');stroka2[5]=Rus('е');stroka2[6]=Rus('н');stroka2[7]=Rus('ы');
			          stroka2[8]=Rus(' ');stroka2[9]=Rus(' ');stroka2[10]=Rus(' ');stroka2[11]=Rus(' ');stroka2[12]=Rus(' ');stroka2[13]=Rus(' ');stroka2[14]=Rus(' ');stroka2[15]=Rus(' ');
					   clr_0();
				  }
			  if (red_xy==1)
				  {
				  privoda_OFF();
		          stroka2[0]=Rus('в');stroka2[1]=Rus('ы');stroka2[2]=Rus('к');stroka2[3]=Rus('л');stroka2[4]=Rus('ю');stroka2[5]=Rus('ч');stroka2[6]=Rus('е');stroka2[7]=Rus('н');
		          stroka2[8]=Rus('ы');stroka2[9]=Rus(' ');stroka2[10]=Rus(' ');stroka2[11]=Rus(' ');stroka2[12]=Rus(' ');stroka2[13]=Rus(' ');stroka2[14]=Rus(' ');stroka2[15]=Rus(' ');
				  clr_0();
				  }
	  }
	  if (temp_menu==8)//цикл ON OFF
	  {
			clr();
            stroka1[0]=Rus('Ц');stroka1[1]=Rus('и');stroka1[2]=Rus('К');stroka1[3]=Rus('Л');stroka1[4]=Rus(' ');stroka1[5]=Rus('В');stroka1[6]=Rus('К');stroka1[7]=Rus('Л');
            stroka1[8]=Rus('/');stroka1[9]=Rus('О');stroka1[10]=Rus('Т');stroka1[11]=Rus('К');stroka1[12]=Rus('Л');stroka1[13]=Rus(' ');stroka1[14]=Rus(' ');stroka1[15]=0x20;
		   clr_0();
	  }
	  if (temp_menu==8 && rejim_red==1)
	  {
			  if (red_xy==1)
				  {
				  	  _cikl=1;
				  	TIM2->CCR1=60;
			          stroka2[0]=Rus('в');stroka2[1]=Rus('к');stroka2[2]=Rus('л');stroka2[3]=Rus('ю');stroka2[4]=Rus('ч');stroka2[5]=Rus('е');stroka2[6]=Rus('н');stroka2[7]=Rus('ы');
			          stroka2[8]=Rus(' ');stroka2[9]=Rus(' ');stroka2[10]=Rus(' ');stroka2[11]=Rus(' ');stroka2[12]=Rus(' ');stroka2[13]=Rus(' ');stroka2[14]=Rus(' ');stroka2[15]=Rus(' ');
					   clr_0();
				  }
			  if (red_xy==0)
				  {
				  _cikl=0;
		          stroka2[0]=Rus('в');stroka2[1]=Rus('ы');stroka2[2]=Rus('к');stroka2[3]=Rus('л');stroka2[4]=Rus('ю');stroka2[5]=Rus('ч');stroka2[6]=Rus('е');stroka2[7]=Rus('н');
		          stroka2[8]=Rus('ы');stroka2[9]=Rus(' ');stroka2[10]=Rus(' ');stroka2[11]=Rus(' ');stroka2[12]=Rus(' ');stroka2[13]=Rus(' ');stroka2[14]=Rus(' ');stroka2[15]=Rus(' ');
				  clr_0();
				  }
	  }
	  if (temp_menu==9)//ехать в ноль
	  {
			clr();
            stroka1[0]=Rus('Е');stroka1[1]=Rus('X');stroka1[2]=Rus('A');stroka1[3]=Rus('T');stroka1[4]=Rus('Ь');stroka1[5]=Rus(' ');stroka1[6]=Rus('В');stroka1[7]=Rus(' ');
            stroka1[8]=Rus('Н');stroka1[9]=Rus('О');stroka1[10]=Rus('Л');stroka1[11]=Rus('Ь');stroka1[12]=Rus(' ');stroka1[13]=Rus(' ');stroka1[14]=Rus(' ');stroka1[15]=0x20;
		   clr_0();
	  }
	  if (temp_menu==9 && rejim_red==1)
	  {
		  privoda_ON();
		  rejim_nuul=1;
	  }
		if (temp_menu==10)//задание для настройки
		{
			clr();
            stroka1[0]=Rus('З');stroka1[1]=Rus('А');stroka1[2]=Rus('Д');stroka1[3]=Rus('А');stroka1[4]=Rus('Т');stroka1[5]=Rus('Ь');stroka1[6]=Rus(' ');stroka1[7]=Rus('К');
            stroka1[8]=Rus('О');stroka1[9]=Rus('О');stroka1[10]=Rus('Р');stroka1[11]=Rus('Д');stroka1[12]=Rus('i');stroka1[13]=Rus('Н');stroka1[14]=Rus('А');stroka1[15]=Rus('Т');
			char _stroka1[16]={0,};
			char _stroka2[16]={0,};
			itoa(tek_scet_x, _stroka1, 10);
			itoa(tek_scet_y, _stroka2, 10);
			stroka2[0]='X';stroka2[1]='=';stroka2[2]=_stroka1[0];stroka2[3]=_stroka1[1];stroka2[4]=_stroka1[2];stroka2[5]=_stroka1[3];stroka2[6]=_stroka1[4];stroka2[7]=_stroka1[5];
			stroka2[8]='Y';stroka2[9]='=';stroka2[10]=_stroka2[0];stroka2[11]=_stroka2[1];stroka2[12]=_stroka2[2];stroka2[13]=_stroka2[3];stroka2[14]=_stroka2[4];stroka2[15]=_stroka2[5];
            clr_0();
		}
		  if (temp_menu==10 && _kn_vverh==1 && rejim_red==1 && _yd_vverh==0 && red_xy==0) zadanie_x++;
		  if (temp_menu==10 && _kn_vverh==1 && rejim_red==1 && _yd_vverh==0 && red_xy==1) zadanie_y++;
		  if (temp_menu==10 && _kn_vniz==1 && rejim_red==1 && _yd_vniz==0 && red_xy==0) zadanie_x--;
		  if (temp_menu==10 && _kn_vniz==1 && rejim_red==1 && _yd_vniz==0 && red_xy==1) zadanie_y--;

		  if (temp_menu==10 && rejim_red==1 && _yd_vverh==1 && red_xy==0 )zadanie_x=zadanie_x+100;
		  if (temp_menu==10 && rejim_red==1 && _yd_vniz==1 && red_xy==0 )zadanie_x=zadanie_x-100;
		  if (temp_menu==10 && rejim_red==1 && _yd_vverh==1 && red_xy==1 )zadanie_y=zadanie_y+100;
		  if (temp_menu==10 && rejim_red==1 && _yd_vniz==1 && red_xy==1 )zadanie_y=zadanie_y-100;

}

void _init_knop()
{
    if (rejim_red==1)
    	{
  	  lcd_set_xy(15, 0);
  	  lcd_send(0xdc,DATA);
    	}
    else {
    	  lcd_set_xy(15, 0);
    	  lcd_send(0xff,DATA);
    	 }
	if (_kn_vverh==1)
    	{
  	  lcd_set_xy(15, 0);
  	  lcd_send(0xd9,DATA);
    	}
    if (_kn_vniz==1)
    	{
  	  lcd_set_xy(15, 0);
  	  lcd_send(0xda,DATA);
    	}
    if (_kn_lazer_5==1)
    	{
  	  lcd_set_xy(15, 0);
  	  lcd_send(0xee,DATA);
    	}
    if (_kn_pusk_cik==1)
    	{
  	  lcd_set_xy(15, 0);
  	  lcd_send(0x7e,DATA);
    	}
    if (_kn_gribok==1)
    	{
  	  lcd_set_xy(15, 0);
  	  lcd_send(0xed,DATA);
    	}
	  if (temp_menu==3 && red_xy==0)
	  {
			lcd_set_xy(15, 1);  lcd_send('X',DATA);
	  }
	  if (temp_menu==3 && red_xy==1)
	  {
			lcd_set_xy(15, 1);  lcd_send('Y',DATA);
	  }
	  if (temp_menu==10 && red_xy==0)
	  {
			lcd_set_xy(15, 1);  lcd_send('X',DATA);
	  }
	  if (temp_menu==10 && red_xy==1)
	  {
			lcd_set_xy(15, 1);  lcd_send('Y',DATA);
	  }
}
void monitor()
{
    lcd_set_xy(0, 0);
    lcd_send(stroka1[0],DATA); lcd_send(stroka1[1],DATA); lcd_send(stroka1[2],DATA); lcd_send(stroka1[3],DATA); lcd_send(stroka1[4],DATA);
    lcd_send(stroka1[5],DATA); lcd_send(stroka1[6],DATA); lcd_send(stroka1[7],DATA); lcd_send(stroka1[8],DATA); lcd_send(stroka1[9],DATA);
    lcd_send(stroka1[10],DATA);lcd_send(stroka1[11],DATA);lcd_send(stroka1[12],DATA);lcd_send(stroka1[13],DATA);lcd_send(stroka1[14],DATA);
    lcd_send(stroka1[15],DATA);
    lcd_set_xy(0, 1);
    lcd_send(stroka2[0],DATA); lcd_send(stroka2[1],DATA); lcd_send(stroka2[2],DATA); lcd_send(stroka2[3],DATA); lcd_send(stroka2[4],DATA);
    lcd_send(stroka2[5],DATA); lcd_send(stroka2[6],DATA); lcd_send(stroka2[7],DATA); lcd_send(stroka2[8],DATA); lcd_send(stroka2[9],DATA);
    lcd_send(stroka2[10],DATA);lcd_send(stroka2[11],DATA);lcd_send(stroka2[12],DATA);lcd_send(stroka2[13],DATA);lcd_send(stroka2[14],DATA);
    lcd_send(stroka2[15],DATA);
}
/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_SPI1_Init();
  MX_FATFS_Init();
  MX_TIM2_Init();
  MX_TIM3_Init();
  MX_TIM4_Init();
  /* USER CODE BEGIN 2 */
  OFF();
  HAL_TIM_Base_Start_IT(&htim3);
  HAL_TIM_Base_Start_IT(&htim4);
  spik(muz[12],150);
  lcd_init();
  spik(muz[10],150);
  lcd_clear();
  lcd_set_xy(0, 0);
  lcd_out("Привет,как дела?");
  lcd_set_xy(0, 1);
  lcd_out("Iнициализация SD");
  HAL_Delay(1000);
  SD_Card_maumt_red_vijigalka();
  HAL_TIM_PWM_Stop(&htim2, TIM_CHANNEL_1);
  TIM2->CCR1=2*60/100;//lazer


  spik(muz[0],60);  spik(muz[1],60);  spik(muz[2],60);  spik(muz[3],60);  spik(muz[4],60);  spik(muz[3],60);  spik(muz[2],60);  spik(muz[1],60);  spik(muz[0],60);
  HAL_GPIO_WritePin(led_GPIO_Port, led_Pin, GPIO_PIN_RESET);
  red_blok_1_2();
  HAL_GPIO_WritePin(led_GPIO_Port, led_Pin, GPIO_PIN_SET);
  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
    while (1)
    {
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */

    	if (upd_zad==1)
    	{
//    		red_blok();
    		upd_zad=0;
    		tek_blok++;
    		red_blok_1();
    	}
    	if (_kn_pusk_cik == 1)_cikl=1;

    	if (	cikl_otrabotan==1)
    		vse();
    	if (	rejim_nuul==1)	NUL_CIKL();
    	if (konc_x==1 || konc_y==1)
    	{_cikl = 0;
    		while (konc_x==1)
    		{
    			  lcd_set_xy(0, 0);
    			  lcd_out("Нажат конц Х    ");
    		}
    		while (konc_y==1)
    		{
  			  lcd_set_xy(0, 1);
  			  lcd_out("Нажат конц Y    ");
    		}

    	}
      monitor();
      _init_menu();
      _init_knop();
//      if (_cikl==0)
//      {
//    	  if (laz_vkl==1) lazer_ON();
//    	  else lazer_OFF();
//      }
      if (temp_menu==11 && rejim_red==0) temp_menu=0;
	  if (_kn_vverh==1 && rejim_red==0) temp_menu++;
	  if (_kn_vniz==1 && rejim_red==0)  temp_menu--;
      if (temp_menu>=11) temp_menu=0;
      if (temp_menu <0) temp_menu=10;
//	  if (naj_kn==0)
//		  {
//		    lcd_set_xy(15, 0);lcd_send(20,DATA);
//			lcd_set_xy(15, 1);lcd_send(20,DATA);
//		  }
    }

  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 25;
  RCC_OscInitStruct.PLL.PLLN = 336;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
  RCC_OscInitStruct.PLL.PLLQ = 7;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief SPI1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_SPI1_Init(void)
{

  /* USER CODE BEGIN SPI1_Init 0 */

  /* USER CODE END SPI1_Init 0 */

  /* USER CODE BEGIN SPI1_Init 1 */

  /* USER CODE END SPI1_Init 1 */
  /* SPI1 parameter configuration*/
  hspi1.Instance = SPI1;
  hspi1.Init.Mode = SPI_MODE_MASTER;
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;
  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
  hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
  hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
  hspi1.Init.NSS = SPI_NSS_SOFT;
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
  hspi1.Init.CRCPolynomial = 10;
  if (HAL_SPI_Init(&hspi1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN SPI1_Init 2 */

  /* USER CODE END SPI1_Init 2 */

}

/**
  * @brief TIM2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM2_Init(void)
{

  /* USER CODE BEGIN TIM2_Init 0 */

  /* USER CODE END TIM2_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};
  TIM_OC_InitTypeDef sConfigOC = {0};

  /* USER CODE BEGIN TIM2_Init 1 */

  /* USER CODE END TIM2_Init 1 */
  htim2.Instance = TIM2;
  htim2.Init.Prescaler = 83;
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim2.Init.Period = 50;
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim2) != HAL_OK)
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_Init(&htim2) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 0;
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM2_Init 2 */

  /* USER CODE END TIM2_Init 2 */
  HAL_TIM_MspPostInit(&htim2);

}

/**
  * @brief TIM3 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM3_Init(void)
{

  /* USER CODE BEGIN TIM3_Init 0 */

  /* USER CODE END TIM3_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};

  /* USER CODE BEGIN TIM3_Init 1 */

  /* USER CODE END TIM3_Init 1 */
  htim3.Instance = TIM3;
  htim3.Init.Prescaler = 83;
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim3.Init.Period = 2000;
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim3) != HAL_OK)
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM3_Init 2 */

  /* USER CODE END TIM3_Init 2 */

}

/**
  * @brief TIM4 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM4_Init(void)
{

  /* USER CODE BEGIN TIM4_Init 0 */

  /* USER CODE END TIM4_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};

  /* USER CODE BEGIN TIM4_Init 1 */

  /* USER CODE END TIM4_Init 1 */
  htim4.Instance = TIM4;
  htim4.Init.Prescaler = 63;
  htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim4.Init.Period = 10000;
  htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim4.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim4) != HAL_OK)
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim4, &sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM4_Init 2 */

  /* USER CODE END TIM4_Init 2 */

}

/**
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(led_GPIO_Port, led_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOA, RS_Pin|EN_Pin|DB5_Pin|DB7_Pin
                          |SD_CS_Pin, GPIO_PIN_SET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, DB6_Pin|DB4_Pin|RW_Pin, GPIO_PIN_SET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, Y_Dir_Pin|Y_STEP_Pin|rezerv6_Pin|rezerv4_Pin
                          |rezerv1_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOA, XY_ENABLE_Pin|Speaker_Pin|X_Dir_Pin|X_STEP_Pin
                          |rezerv5_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin : led_Pin */
  GPIO_InitStruct.Pin = led_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(led_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pins : vverh_Pin vniz_Pin */
  GPIO_InitStruct.Pin = vverh_Pin|vniz_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

  /*Configure GPIO pins : RS_Pin EN_Pin DB5_Pin DB7_Pin
                           Speaker_Pin */
  GPIO_InitStruct.Pin = RS_Pin|EN_Pin|DB5_Pin|DB7_Pin
                          |Speaker_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

  /*Configure GPIO pin : SD_CS_Pin */
  GPIO_InitStruct.Pin = SD_CS_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(SD_CS_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pins : DB6_Pin DB4_Pin RW_Pin */
  GPIO_InitStruct.Pin = DB6_Pin|DB4_Pin|RW_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

  /*Configure GPIO pins : Y_Dir_Pin Y_STEP_Pin rezerv1_Pin */
  GPIO_InitStruct.Pin = Y_Dir_Pin|Y_STEP_Pin|rezerv1_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_MEDIUM;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

  /*Configure GPIO pins : PB12 PB13 */
  GPIO_InitStruct.Pin = GPIO_PIN_12|GPIO_PIN_13;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

  /*Configure GPIO pins : rezerv6_Pin rezerv4_Pin */
  GPIO_InitStruct.Pin = rezerv6_Pin|rezerv4_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

  /*Configure GPIO pins : XY_ENABLE_Pin X_Dir_Pin X_STEP_Pin */
  GPIO_InitStruct.Pin = XY_ENABLE_Pin|X_Dir_Pin|X_STEP_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_MEDIUM;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

  /*Configure GPIO pin : rezerv5_Pin */
  GPIO_InitStruct.Pin = rezerv5_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(rezerv5_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pins : rezerv3_Pin vvod_Pin gribok_Pin pusk_cikl_Pin
                           lazer_5_Pin */
  GPIO_InitStruct.Pin = rezerv3_Pin|vvod_Pin|gribok_Pin|pusk_cikl_Pin
                          |lazer_5_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

}

/* USER CODE BEGIN 4 */

/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
